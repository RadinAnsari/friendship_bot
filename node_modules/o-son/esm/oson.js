// deno-lint-ignore-file no-explicit-any
// magic numbers for values
export const UNDEFINED_INDEX = -1;
export const ARRAY_HOLE_INDEX = -2;
export const NAN_INDEX = -3;
export const POS_INF_INDEX = -4;
export const NEG_INF_INDEX = -5;
// magic numbers for oson list type labels
export const BIG_INT_LABEL = -6;
function isOsonObject(array) {
    return typeof array[0] === "string";
}
function isOsonBigInt(array) {
    return array[0] === BIG_INT_LABEL;
}
export * from "./constructors.js";
import { GLOBAL_CONSTRUCTOR_MAP, PLAIN_OBJECT_LABEL, } from "./constructors.js";
export function stringify(value = undefined, constructors = GLOBAL_CONSTRUCTOR_MAP) {
    return JSON.stringify(listify(value, constructors));
}
export function parse(text, constructors = GLOBAL_CONSTRUCTOR_MAP) {
    return delistify(JSON.parse(text), constructors);
}
function toMagicNumber(value) {
    if (value === undefined)
        return UNDEFINED_INDEX;
    if (typeof value === "number") {
        if (isNaN(value))
            return NAN_INDEX;
        if (!isFinite(value))
            return value < 0 ? NEG_INF_INDEX : POS_INF_INDEX;
    }
    return null;
}
function fromMagicNumber(value) {
    switch (value) {
        case UNDEFINED_INDEX:
            return undefined;
        case NAN_INDEX:
            return NaN;
        case NEG_INF_INDEX:
            return -Infinity;
        case POS_INF_INDEX:
            return Infinity;
        default:
            return null;
    }
}
const SPARSE_PROTO = [];
function sparse(len) {
    if (SPARSE_PROTO.length < len) {
        const old = SPARSE_PROTO.length;
        SPARSE_PROTO.length = len;
        SPARSE_PROTO.fill(ARRAY_HOLE_INDEX, old, len);
    }
    return SPARSE_PROTO.slice(0, len);
}
function fromObject(value, constructors) {
    // check if we have this instance registered
    const constr = value.constructor;
    if (typeof constr === "function") {
        const label = constr.name;
        const inst = constructors.get(label);
        if (inst !== undefined) {
            return [label, inst.from(value)];
        }
    }
    // no instance found, fall back to normal object
    const entries = Object.entries(value);
    const cnt = entries.length;
    const val = Array(cnt + cnt);
    for (let i = 0; i < cnt; i++) {
        const entry = entries[i];
        const ii = i + i;
        val[ii] = entry[0];
        val[ii + 1] = entry[1];
    }
    return [PLAIN_OBJECT_LABEL, val];
}
function stubObject(label, constructors) {
    // stub a plain object
    if (label === PLAIN_OBJECT_LABEL)
        return {};
    // stub an instance
    const stub = constructors.get(label);
    if (stub === undefined) {
        throw new Error(`Unknown stub type: ${label}`);
    }
    if ("stub" in stub)
        return stub.stub();
    else
        return undefined;
}
function hydrateObject(label, stub, val, constructors) {
    if (label === PLAIN_OBJECT_LABEL) {
        const object = stub;
        for (let i = 0; i < val.length; i += 2) {
            object[val[i]] = val[i + 1];
        }
        return object;
    }
    const hydrator = constructors.get(label);
    if (hydrator === undefined) {
        throw new Error(`Unknown object type: ${label}`);
    }
    if (!("hydrate" in hydrator)) {
        throw new Error(`Do not know how to hydrate stub type: ${label}`);
    }
    hydrator.hydrate(stub, val);
}
function createObject(label, val, constructors) {
    const creator = constructors.get(label);
    if (creator === undefined) {
        throw new Error(`Unknown object type: ${label}`);
    }
    if (!("create" in creator)) {
        throw new Error(`Do not know how to create object type: ${label}`);
    }
    return creator.create(val);
}
export function listify(value, constructors = GLOBAL_CONSTRUCTOR_MAP) {
    const num = toMagicNumber(value);
    if (num !== null)
        return num;
    const list = [];
    const index = new Map();
    add(value);
    return list;
    function add(value) {
        const num = toMagicNumber(value);
        if (num !== null)
            return num;
        let position = index.get(value);
        if (position !== undefined)
            return position;
        position = list.length;
        switch (typeof value) {
            case "number":
            case "string":
            case "boolean":
                list[position] = value;
                index.set(value, position);
                break;
            case "bigint": {
                list[position] = [BIG_INT_LABEL, value.toString(16)];
                index.set(value, position);
                break;
            }
            case "object":
                if (value === null) {
                    list[position] = value;
                    index.set(value, position);
                }
                else if (Array.isArray(value)) {
                    const arr = sparse(value.length);
                    list[position] = arr;
                    index.set(value, position);
                    for (const i in value) {
                        arr[i] = add(value[i]);
                    }
                }
                else {
                    const [label, vals] = fromObject(value, constructors);
                    const len = vals.length;
                    const arr = Array(len + 1);
                    arr[0] = label;
                    list[position] = arr;
                    index.set(value, position);
                    for (let i = 0; i < len; i++) {
                        arr[i + 1] = add(vals[i]);
                    }
                }
        }
        return position;
    }
}
export function delistify(oson, constructors = GLOBAL_CONSTRUCTOR_MAP) {
    if (!Array.isArray(oson)) {
        const val = fromMagicNumber(oson);
        if (val !== null)
            return val;
        else
            throw new Error(`Invalid Oson: ${oson}`);
    }
    if (oson.length === 0)
        throw new Error("Empty Oson data!");
    const list = oson;
    const index = Array(oson.length);
    recover(0);
    return index[0];
    function recover(position) {
        const val = fromMagicNumber(position);
        if (val !== null)
            return val;
        if (!(position in index)) {
            const value = list[position];
            switch (typeof value) {
                case "object":
                    if (value !== null) {
                        if (isOsonBigInt(value)) {
                            const val = value[1];
                            const num = val.startsWith("-")
                                ? -BigInt("0x" + val.substring(1))
                                : BigInt("0x" + val);
                            index[position] = num;
                        }
                        else if (isOsonObject(value)) {
                            const [label, ...vals] = value;
                            const stub = stubObject(label, constructors);
                            if (stub === undefined) {
                                const v = vals.map(recover);
                                const o = createObject(label, v, constructors);
                                index[position] = o;
                            }
                            else {
                                index[position] = stub;
                                const v = vals.map(recover);
                                hydrateObject(label, stub, v, constructors);
                            }
                        }
                        else {
                            const len = value.length;
                            const array = Array(len);
                            index[position] = array;
                            for (let i = 0; i < len; i++) {
                                const val = value[i];
                                if (val !== ARRAY_HOLE_INDEX) {
                                    array[i] = recover(val);
                                }
                            }
                        }
                        break;
                    }
                // fallthrough for null
                case "string":
                case "boolean":
                case "number":
                    index[position] = value;
                    break;
            }
        }
        return index[position];
    }
}
